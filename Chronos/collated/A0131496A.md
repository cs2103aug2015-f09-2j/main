# A0131496A
###### src\application\AlarmCommand.java
``` java
public class AlarmCommand extends UpdateCommand {
	
	private static final String FEEDBACK_INVALID_COMMAND = "Error: Invalid Command";
	private static final String ALARM_OFF = "off";
	private static final String JSON_ALRAM = "alarm";
	private static final String JSON_START_DATE = "start date";
	private static final String JSON_END_DATE = "due date";
	private static final int FIELDS_NUM = 2;
	
	/**
	 * Alarm command should have 2 fields, the id to identify task/event, and
	 * 	 either "off" to denote turning off the alarm
	 *   or the number of hours before the event starts or the task finishes that the alarm should go off
	 * @param content
	 */
	public AlarmCommand(String content) {
		super(content);
	}

	@Override
	public Feedback execute() {
		try{
		String[] alarmDetails = _parse.parseAlarmString(_content);
		if (alarmDetails.length != FIELDS_NUM){
			return new Feedback(FEEDBACK_INVALID_COMMAND);
		}
		String taskID = alarmDetails[0];
		//call parent method
		_index = findEntry(taskID);
		if (_index > LIMIT_ID) {
			performUpdate(alarmDetails);
			_isSuccessful = true;
			String feedbackString = String.format(FEEDBACK_MESSAGE, _content);
			return new Feedback(feedbackString);
		} else {
			return new Feedback(ERROR_INVALID_ID);
		}
		}catch (NumberFormatException | ParseException e) {
			return new Feedback(FEEDBACK_INVALID_COMMAND);
		}
	}

	private void performUpdate(String[] alarmDetails) throws ParseException {
		_store.storeTemp();
		JSONObject entry = (JSONObject) _store.entries_.get(_index);
		updateAlarm(entry, alarmDetails);
		_store.storeChanges();
	}
	
	//Suppress the warnings from JSON syntax, no effect on how the code works
	@SuppressWarnings("unchecked")
	private void updateAlarm(JSONObject entry, String[] alarmDetails) throws NumberFormatException, ParseException{
		if(alarmDetails[1].equals(ALARM_OFF)){
			entry.replace(JSON_ALRAM,ALARM_OFF);
		}else{
			String alarmOffset = findAlarmOffset(entry);
			DateFormat dateFormat = new SimpleDateFormat(Task.DATE_FORMAT); 
			Date offset = dateFormat.parse(alarmOffset);
			int hoursPrior = Integer.parseInt(alarmDetails[1]);
			Date newAlarm = getNewAlarm(hoursPrior, offset);
			String alarmString = dateFormat.format(newAlarm);
			entry.replace(JSON_ALRAM, alarmString);
		}
	}

	private Date getNewAlarm(int hoursPrior, Date offset) {
		Calendar cal = Calendar.getInstance();
		cal.setTime(offset);
		//The new absolute alarm time should be hoursPrior before the offset
		cal.add(Calendar.HOUR, hoursPrior*(-1));
		Date alarm = cal.getTime();
		return alarm;
	}

	private String findAlarmOffset(JSONObject entry) {
		String alarmOffset;
		if (entry.containsKey(JSON_START_DATE)){
			//if it is event, alarm should be calculated from the start time
			alarmOffset = entry.get(JSON_START_DATE).toString();
		}else{
			//else it is task, alarm should be calculated from the end time
			alarmOffset = entry.get(JSON_END_DATE).toString();
		}
		return alarmOffset;
	}

}
```
###### src\application\Storage.java
``` java
public class Storage {

	private final String MESSAGE_INVALID_FILE = "Invalid File.";
	private final String MESSAGE_FILE_CREATED = "Your agenda will be stored in \"%1$s\"";
	private final String MESSAGE_FILE_OPENED = "Your agenda stored in \"%1$s\" is loaded";
	private final String MESSAGE_FILE_SWAPPED = "content of %1$s moved to %2$s";
	private final String MESSAGE_ERROR_DELETE = "old file %1$s not deleted";
	private final String MESSAGE_TEMP_SWAPPED = "swapped entries_ with temp_entries";
	private static final String PREFS_PATH = "path";
	private static final String PREFS_TASK_COUNT = "task count";
	private static final String PREFS_EVENT_COUNT = "event count";
	private static final String DEFAULT_DIRECTORY = "/chronos_storage.txt";
	private static final String DEFAULT_PATH = "none";
	private static final String[] ESSENTIAL_FIELDS = {"id","due date","description","priority","category","complete","alarm"};
	private static final char TASK_PREFIX = 't';
	private static final char EVENT_PREFIX = 'e';
	private static final int ERROR_TYPE_ID = 0;
	private static  int  DEFAULT_TASK_COUNT = 0;
	private static  int  DEFAULT_EVENT_COUNT = 0;
	
	private static Logger log = Logger.getLogger("StorageLog");
	
	public JSONArray entries_;
	private JSONArray tempEntries_;
	private String tempFileDirectory_;
	private String fileDirectory_;
	private static Preferences userPrefs_;
	private boolean isStoredTemp_ = false;
	private boolean isSavePresent_ = false;
	
	private static Storage theStorage_;
	
	private Storage() { 
		entries_ = new JSONArray();
		userPrefs_ = Preferences.userNodeForPackage(this.getClass());
		String savedPath = userPrefs_.get(PREFS_PATH, DEFAULT_PATH);
		if (!savedPath.equals(DEFAULT_PATH)) { 
			//If user has specified where to save, just open it
			getFile(savedPath);
			isSavePresent_ = true;
		} 
	}
	
	public static Storage getInstance() {
		if (theStorage_ == null) {
			theStorage_ = new Storage();
		}
		return theStorage_;
	}
	
	void initialize(String path) { 
		//store user specified directory into user preference
		userPrefs_.put(PREFS_PATH, path);
		//check if there's already chronos_storage in it and get the maximum id's
		userPrefs_.putInt(PREFS_TASK_COUNT, DEFAULT_TASK_COUNT);
		userPrefs_.putInt(PREFS_EVENT_COUNT, DEFAULT_EVENT_COUNT);
		getFile(path);
	}
	
	private void getFile(String filePath){
		fileDirectory_ = filePath;
		readFile();	
	}
	
	private void readFile(){
		File file = new File(fileDirectory_ + DEFAULT_DIRECTORY );
		try {
			if(!file.createNewFile()){ 
				//Read in the content of an existing file
				getContent(fileDirectory_);
				checkValidFormat();
				getMaxId();
				log.info(String.format(MESSAGE_FILE_OPENED, fileDirectory_));
			}else{
				log.info(String.format(MESSAGE_FILE_CREATED, fileDirectory_));
			}
		} catch (IOException | ParseException e) {
			log.warning(MESSAGE_INVALID_FILE);
		}
	}
	
	//throws exception if the JSON format is incorrect i.e. does not contain the essential fields
	public void checkValidFormat() throws ParseException{
		JSONObject anEntry;
		for (int i = 0; i<entries_.size();i++){
			anEntry = (JSONObject)entries_.get(i);
			String key;
			//"id" field will be tested in getMaxId method, so there is no need to check it here
			for(int j = 1; j<ESSENTIAL_FIELDS.length; j++){
				key = ESSENTIAL_FIELDS[j];
				if(anEntry.get(key)==null){
					throw new ParseException(j);
				}
			}			
		}
	}
	
	private void getMaxId() throws ParseException{
		String idString;
		int maxTaskId = 0, maxEventId = 0;
		JSONObject anEntry;
		for (int i = 0; i<entries_.size();i++){
			anEntry = (JSONObject)entries_.get(i);
			idString = (String) anEntry.get("id");
			switch (idString.charAt(0)){
				case TASK_PREFIX:
					maxTaskId = compareId(idString, maxTaskId);
					break;
				case EVENT_PREFIX:
					maxEventId = compareId(idString, maxEventId);
					break;
				default:
					throw new ParseException(ERROR_TYPE_ID);
			}
		}
		DEFAULT_TASK_COUNT = maxTaskId;
		DEFAULT_EVENT_COUNT = maxEventId;
		userPrefs_.putInt(PREFS_TASK_COUNT, DEFAULT_TASK_COUNT);
		userPrefs_.putInt(PREFS_EVENT_COUNT, DEFAULT_EVENT_COUNT);
	}

	private int compareId(String idString, int maxId) {
		int id;
		id = Integer.parseInt(idString.substring(1));
		if (id>maxId){
			maxId = id;
		}
		return maxId;
	}
	
	//throws exception if the file is not in JSON format
	public void getContent(String fileDirectory) throws  ParseException, IOException{
		JSONParser jsonParser = new JSONParser();
		entries_ = (JSONArray)jsonParser.parse(new FileReader(fileDirectory+DEFAULT_DIRECTORY ));
	}
	
	//to be called before an add, delete, update i.e. commands that will change the content of the file
	public void storeTemp(){
		tempEntries_ = (JSONArray) entries_.clone();
		isStoredTemp_ = true;	
	}
	
	//to be called after changes to the content of the file
	public void storeChanges(){
		//the entries have to be stored before making changes
		assert isStoredTemp_ == true;
		isStoredTemp_ = false;
		writeToFile();
	}
	
	//to be called by undo/redo commands that undo/redo add/delete/update commands
	public void swapTemp(){
		JSONArray placeHolder = entries_;
		entries_ = tempEntries_;
		tempEntries_ = placeHolder;
		writeToFile();	
		log.info(MESSAGE_TEMP_SWAPPED);
	}
	
	public String changeDirectory(String newDirectory){
		tempFileDirectory_ = fileDirectory_;
		fileDirectory_ = newDirectory;
		writeToFile();
		File oldFile = new File(tempFileDirectory_+DEFAULT_DIRECTORY );
		//Check if file is deleted
		if (!oldFile.delete()) {
			log.warning(String.format(MESSAGE_ERROR_DELETE, tempFileDirectory_));
		} else {
			log.info(String.format(MESSAGE_FILE_SWAPPED, tempFileDirectory_,fileDirectory_));
		}
		//update user preference
		userPrefs_.put(PREFS_PATH, newDirectory);
		return tempFileDirectory_;
	}
	
	
	private void writeToFile(){
		try{
			FileWriter file = new FileWriter(fileDirectory_+DEFAULT_DIRECTORY );
			file.write(entries_.toJSONString());
			file.flush();
			file.close();
		}catch(IOException e){
			e.printStackTrace();
		}
	}

	public boolean checkIsSavePresent() {
		return isSavePresent_;
	}

	public int getTaskId() { 
		int id = userPrefs_.getInt(PREFS_TASK_COUNT, DEFAULT_TASK_COUNT);
		userPrefs_.putInt(PREFS_TASK_COUNT, ++id);
		return id;
	}

	void decreaseTaskID() {
		int id = userPrefs_.getInt(PREFS_TASK_COUNT, DEFAULT_TASK_COUNT);
		userPrefs_.putInt(PREFS_TASK_COUNT, --id);
	}
	
	public int getEventId() { 
		int id = userPrefs_.getInt(PREFS_EVENT_COUNT, DEFAULT_EVENT_COUNT);
		userPrefs_.putInt(PREFS_EVENT_COUNT, ++id);
		return id;
	}

	void decreaseEventID() {
		int id = userPrefs_.getInt(PREFS_EVENT_COUNT, DEFAULT_EVENT_COUNT);
		userPrefs_.putInt(PREFS_EVENT_COUNT, --id);
	}
}
```
###### src\application\UpdateCommand.java
``` java
	/**
	 * This method allows multiple updates of the fields of the entry
	 * @param entry
	 * @param updateDetails
	 */
	protected void updateEntry(JSONObject entry, ArrayList<String> updateDetails) {
		String field,value;
		Span aSpan;
		DateFormat dateFormat = new SimpleDateFormat(Task.DATE_FORMAT);
		String id = entry.get(Parser.JSON_ID).toString();
		boolean isAlarmChanged = false;
		
		for (int j=1; j<updateDetails.size();j++){
			field = updateDetails.get(j);
			value = updateDetails.get(++j);
			if (field.equals(JSON_END_DATE)||field.equals(JSON_START_DATE)){
				//if there is a change in dates, we have to update the alarm
				isAlarmChanged = true;
				aSpan = Chronic.parse(value);	
				value = dateFormat.format(aSpan.getBeginCalendar().getTime());
			}
			id = updateField(entry, field, value, id);
		}
		//alarm will be updated if there is a need to do so
		updateAlarm(entry, dateFormat, id, isAlarmChanged);
	}

```
###### src\application\UpdateCommand.java
``` java
	private void updateAlarm(JSONObject entry, DateFormat dateFormat,
			String id, boolean isAlarmChanged) {
		int hoursPrior = checkHoursPrior(entry, dateFormat);
		if (hoursPrior != -1 && isAlarmChanged){
			AlarmCommand setAlarm = new AlarmCommand(String.format(ALARM_COMMAND, id, hoursPrior));
			setAlarm.execute();
		}
	}

	private String updateField(JSONObject entry, String field, String value,
			String id) {
		if(entry.get(JSON_START_DATE) == null &&field.equals(JSON_START_DATE)) {//convert task to event
				Event event = taskToEvent(entry, value);
				id = event.getId();
				DeleteCommand deleteTask = new DeleteCommand(entry.get(_parse.JSON_ID).toString());
				deleteTask.execute();
				_store.entries_.add(_parse.convertToJSON(event));
		}else {			//for event and  updating task as usual
			entry.replace(field,value);
			_store.entries_.set(_index, entry);
		}
		return id;
	}

```
###### src\application\UpdateCommand.java
``` java
	private int checkHoursPrior(JSONObject entry, DateFormat dateFormat) {
		try{
			//check if the entry has alarm
			if(entry.get(JSON_ALARM) != OFF_ALARM){
				Task aTask = _parse.convertToTask(entry);
				String alarmOffset = aTask.getAlarmOffset();
				Date alarmCalculatedFrom = dateFormat.parse(alarmOffset);
				Date alarm = dateFormat.parse(entry.get(JSON_ALARM).toString());
				//return the number of hours of difference between the alarm and the offset
				return (int)( alarmCalculatedFrom.getTime() - alarm.getTime())/HOUR_TO_MILLI;
			}else{
				return -1;
			}
		}catch (ParseException e){
			log.info(ERROR_PARSING_ALARM);
			return -1;
		}
	}
	
	private Event taskToEvent(JSONObject task, String value) {
		String desc = task.get(_parse.JSON_DESC).toString();
		String endDate = task.get(_parse.JSON_END_DATE).toString();
		String priority = task.get(_parse.JSON_PRIORITY).toString();
		String category = task.get(_parse.JSON_CATEGORY).toString();
		String alarm = task.get(_parse.JSON_ALARM).toString();
		Event event = new Event(EMPTY, desc, EMPTY, endDate, priority, category, alarm);
		event.setStartDate(value);
		event.setId(_store.getEventId());
		return event;
	}

	@Override
	public Feedback undo() {
		_store.storeTemp();
		JSONObject entry = (JSONObject) _store.entries_.get(_index);
		_store.entries_.set(_index, _oldEntry);
		_store.storeChanges();
		String feedbackString = String.format(FEEDBACK_MESSAGE_UNDO, _content);
		return new Feedback(feedbackString);
	}
	
	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_ID);
	    commandInstruction.addToInstructions(INSTRUCTION_OPTIONAL);
		return commandInstruction;
	}
	
}
```
###### src\gui\GUI.java
``` java
	/**
	 * This method produce a pop-up window as the alarm.
	 * The pop-up contains the id and description of the task/event,
	 * and the start time for event or the due time for task.
	 * After the user closes the pop-up, the alarm is turned off.
	 * @param currentTask
	 */
	protected static void triggerAlarm(Task currentTask) {
		Stage dialog = new Stage();
		dialog.initOwner(_stage);
		VBox dialogVbox = createDialog(currentTask);
		Scene dialogScene = new Scene(dialogVbox, 300, 100);
		dialog.setScene(dialogScene);
		dialog.show();
		logic.switchOffAlarm(currentTask);
	}

```
###### src\gui\GUI.java
``` java
	private static VBox createDialog(Task currentTask) {
		VBox dialogVbox = new VBox();
		dialogVbox.alignmentProperty().set(Pos.CENTER);
		Text messageShown = getShownMessage(currentTask);
		dialogVbox.getChildren().add(messageShown);
		return dialogVbox;
	}

```
###### src\gui\GUI.java
``` java
	private static Text getShownMessage(Task currentTask) {
		String warnTime = logic.getAlarmOffset(currentTask);
		String message = String.format(MESSAGE_ALARM, currentTask.getId(), warnTime,currentTask.getDescription());
		Text messageShown = new Text(message);
		messageShown.setFont(Font.font("Arial"));
		messageShown.setTextAlignment(TextAlignment.CENTER);
		return messageShown;
	}

	private void updateFeedback(Feedback feedback) {
		if (feedback.isProgramExiting()) {
			try {
				GlobalScreen.unregisterNativeHook();
			} catch (NativeHookException e) {
				log.warning(MESSAGE_UNREGISTER_NATIVEHOOK_FAIL);
			}
			System.exit(EXIT_NORMAL);
		}
		// choose between summary or detail view
		if (feedback.isInSummaryView()) {
			addSummary();
		} else {
			addDetailView(feedback.getData());
		}
		if (feedback.hasData()) {
			updateSummary(feedback.getData());
		} else {
			// update display
			updateFeedback(logic.updateDisplay());
		}
		commandBarController.displayFeedback(feedback.getMessage());
	}

	public void handleCommandPattern(String text) {
		currentInstruction = Logic.getCommandInstruction(text);
		isHandlingCommand = true;
		handleCommandPattern();
	}

	public void handleCommandPattern() {
		// assert Instruction != null

		// display to feedback String
		String feedbackString = currentInstruction.getCommandPattern();
		if (currentInstruction.hasInstructions()) {
			feedbackString = feedbackString + "\n" + currentInstruction.getNextInstruction();
		}
		commandBarController.displayFeedback(feedbackString);

		// display command pattern to Command Bar (ideal)
		commandBarController.updateCommandBar(currentInstruction.getNextRequiredField());

		currentInstruction.nextStep();

		if (currentInstruction.isFinished()) {
			isHandlingCommand = false;
			commandBarController.hasAComma = false;
		}
	}

	public void retrievePastCommand() {
		String pastCommand = Logic.getPreviouslyTypedCommand();
		try {
			commandBarController.displayTypedCommand(pastCommand);
		} catch (NullPointerException e) {
			// do nothing
		}
	}

	public void retrieveNextCommand() {
		String pastCommand = Logic.getNextTypedCommand();
		try {
			commandBarController.displayTypedCommand(pastCommand);
		} catch (NullPointerException e) {
			// do nothing
		}
	}

	@Override
	public void nativeKeyReleased(NativeKeyEvent arg0) {
		// To do nothing
	}

	@Override
	public void nativeKeyTyped(NativeKeyEvent arg0) {
		// To do nothing
	}

}
```
###### src\gui\SummaryController.java
``` java
	/**
	 * To be called when the currentTask has an alarm.
	 * This method calls GUI to give alarm if the current time is later than the alarm the user set
	 * @param currentTask
	 */
	private void checkAlarm(Task currentTask){
		Date alarm = currentTask.getAlarmDate();
		//format the current time the same way as the alarm for easy comparison
		new SimpleDateFormat(Task.DATE_FORMAT); 
		Date now = new Date();
		if (alarm.before(now)){
			GUI.triggerAlarm(currentTask);
		}
	}
	
```
###### src\test\testCommands.java
``` java
/**
 * Unit tests for the different commands.
 * All tests are performed on the same storage file. 
 * If commands change the content of the storage, call undo() to restore the original storage file.
 **/
public class testCommands {
	
	static Logic logic = Logic.getInstance();
	static Storage store;
	static CommandCreator creator = new CommandCreator();
	static final String DEFAULT_PATH= "none";
	static final String PREFS_PATH = "path";
	static final String TEST_FILE = "src/test/testFiles/testSome";
	static final String JSON_NOTES = "notes";
	static final String JSON_NOTE = "note";
	static String path;
	static Preferences userPrefs = Preferences.userNodeForPackage(Storage.class);

	
	@BeforeClass
	//Store the file path in user preference in String path
	public static void setUp(){
		path = userPrefs.get(PREFS_PATH, DEFAULT_PATH);
		logic.isSavePresent();
		creator.executeInitializeCommand(TEST_FILE);
		store = Storage.getInstance();
	}
	
	@AfterClass
	//Restore the user preferred file path
	public static void cleanUp(){
		userPrefs.put(PREFS_PATH, path);
	}

	@Test
	public void testAdd() {
		Command addCmd = new AddCommand("buy milk, Nov 12 10am, p:high, c:personal");
		addCmd.execute();
		JSONObject entry = (JSONObject)store.entries_.get(5);
		assertEquals("buy milk",entry.get("description").toString() );
		addCmd.undo();
	}
	
	@Test
	public void testUpdate(){
		Command updateCmd = new UpdateCommand("e2, c:pet");
		updateCmd.execute();
		JSONObject entry = (JSONObject) store.entries_.get(3);
		assertEquals("pet", entry.get("category") );
		updateCmd.undo();
	}

	@Test
	public void testSearch(){
	    Command searchCmd = new SearchCommand("buy");
		Feedback searchFeedback = searchCmd.execute();
		ArrayList<Task> actual = searchFeedback.getData();
		ArrayList<Task> expected= new ArrayList<Task>();
		expected.add(new Task("t1", "buy grocery", "08 Nov 2015 12:00", "low", "none","off"));
		assertEquals(expected.toString(), actual.toString());
	}
	
	@Test
	public void testAddNote(){
		Command addNoteCmd = new NoteCommand("e1, bring documents");
		addNoteCmd.execute();
		JSONObject entry= (JSONObject) store.entries_.get(1);
		JSONArray notes = (JSONArray)entry.get(JSON_NOTES);
		JSONObject note = (JSONObject) notes.get(0);
		String expected = "bring documents";
		String actual = note.get(JSON_NOTE).toString();
		assertEquals(expected, actual);
		addNoteCmd.undo();
	}
	
	@Test
	public void testAlarm(){
		Command alarmCmd = new AlarmCommand("e1, 1");
		alarmCmd.execute();
		JSONObject entry= (JSONObject) store.entries_.get(1);
		String expected = "07 Nov 2015 08:00";
		assertEquals(expected, entry.get(Parser.JSON_ALARM));
		alarmCmd.undo();
	}
	
}
```
###### src\test\testStorage.java
``` java
package test;

import static org.junit.Assert.*;

import java.util.prefs.Preferences;

import application.CommandCreator;
import application.Storage;

import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;


public class testStorage {
	
	Storage store;
	JSONArray entries;
	CommandCreator creator = new CommandCreator();
	static Preferences userPrefs = Preferences.userNodeForPackage(Storage.class);
	static final String DEFAULT_PATH= "none";
	static final String PREFS_PATH = "path";
	static final String TEST_FILE_EMPTY = "src/test/testFiles/testEmpty";
	static final String TEST_FILE_SOME = "src/test/testFiles/testSome";
	static final String TEST_FILE_MANY = "src/test/testFiles/testMany";
	static final String TEST_FILE_NOT_JSON = "src/test/testFiles/testInvalid";
	static final String TEST_FILE_WRONG_JASON = "src/test/testFiles/testIncorrect";
	
	static String path;

	@BeforeClass
	//Store the file path in user preference before testing
	public static void setUp(){
		path = userPrefs.get(PREFS_PATH, DEFAULT_PATH);
	}
	
	@AfterClass
	//Restore the file path in user preference
	public static void cleanUp(){
		userPrefs.put(PREFS_PATH, path);
	}

	/*
	 * Test reading in of files
	 * partitions: valid, boundaries: no content, some content, lots of content
	 * 				   invalid, boundaries: not JSON format, incorrect JSON format
	 */
	@Test
	//test boundary case of "no content" 
	public void testReadEmpty(){
		creator.executeInitializeCommand(TEST_FILE_EMPTY);
		store = Storage.getInstance();
		entries = store.entries_;
		assertEquals(entries.size(), 0);
	}
	
	@Test
	//test boundary case of "some content" 
	public void testReadSome() {	
		creator.executeInitializeCommand(TEST_FILE_SOME);
		store = Storage.getInstance();
		entries = store.entries_;
		assertEquals(entries.size(), 5);
		String expected = "{\"start date\":\"07 Nov 2015 09:00\",\"due date\":\"07 Nov 2015 10:00\",\"alarm\":\"off\",\"description\":\"meeting with boss\",\"id\":\"e1\",\"priority\":\"high\",\"category\":\"work\",\"complete\":false}";
		assertEquals(expected, entries.get(1).toString());
		JSONObject entry = (JSONObject) entries.get(3);
		assertEquals("walk the dog", entry.get("description"));
	}
	
	@Test
	//test boundary case of "lots of content"
	public void testReadMany(){
		creator.executeInitializeCommand(TEST_FILE_MANY);
		store = Storage.getInstance();
		entries = store.entries_;
		assertEquals(200, entries.size());
		String expected = "{\"start date\":\"07 Nov 2015 09:00\",\"due date\":\"07 Nov 2015 10:00\",\"alarm\":\"off\",\"description\":\"meeting with boss\",\"id\":\"e1\",\"priority\":\"high\",\"category\":\"work\",\"complete\":false}";
		assertEquals(expected, entries.get(60).toString());
		JSONObject entry = (JSONObject) entries.get(40);
		assertEquals("meeting with boss", entry.get("description"));
	}
	
	@Test
	//test boundary case of "not JSON format" 
	public void testInvalid(){
		Throwable caught = null;
		store = Storage.getInstance();
		try {
			store.getContent(TEST_FILE_NOT_JSON);
		} catch (Throwable e) {
			caught = e;
		}
		assertSame(org.json.simple.parser.ParseException.class,caught.getClass());	
	}
	
	@Test
	//test boundary case of "incorrect JSON format"
	public void testIncorrect(){
		Throwable caught = null;
		store = Storage.getInstance();
		try {
			store.getContent(TEST_FILE_WRONG_JASON);
			store.checkValidFormat();
		} catch (Throwable e) {
			caught = e;
		}
		assertSame(org.json.simple.parser.ParseException.class,caught.getClass());	
	}
}
```
###### src\test\testSystem.java
``` java
//Fix the running order of the test methods
@FixMethodOrder(MethodSorters.NAME_ASCENDING)

/**
 * This is a series of consecutive system testing. 
 * Except for the first testInitialisation method where it confirms the file is read in correctly,
 * all other test methods take in user commands as they are and run them in black box.
 * The commands run consecutively to simulate a user's work flow.
 * A storage file with 20 entries at the start is used for testing
 */
public class testSystem {
	
	static Storage store;
	static Logic logic = Logic.getInstance();
	static JSONArray entries;
	static CommandCreator creator = new CommandCreator();
	static Preferences userPrefs = Preferences.userNodeForPackage(Storage.class);
	static final String DEFAULT_PATH= "none";
	static final String PREFS_PATH = "path";
	static final String TEST_DIR = "src/test/testFiles/testSystem";
	static final String TEST_FILE = "src/test/testFiles/testSystem/chronos_storage.txt";
	//Backup file is a copy of the original test file
	static final String BACKUP_FILE = "src/test/testFiles/temp/testSystem.txt";
	static String path;

	@BeforeClass
	//Store the file path in user preference
	public static void setUpBeforeClass() throws Exception {
		path = userPrefs.get(PREFS_PATH, DEFAULT_PATH);
	}

	@AfterClass
	//Restore the file path in user preference
	//Since the content in the test file has been changed, rewrite it with the content of the backup file
	//to ensure the test cases' reproducibility
	public static void tearDownAfterClass() throws Exception {
		userPrefs.put(PREFS_PATH, path);
		File from = new File(BACKUP_FILE);
		File to = new File(TEST_FILE);
		//delete the changed test file first
		to.delete();
		Files.copy(from.toPath(), to.toPath());
	}
	
	@Test
	//Test by random sampling if the file is read in properly
	public void a_testInitialisation() {
		creator.executeInitializeCommand(TEST_DIR);
		store = Storage.getInstance();
		entries = store.entries_;
		logic.isSavePresent();
		assertEquals(20,entries.size());
		String expected = "{\"due date\":\"08 Nov 2015 22:00\",\"alarm\":\"off\",\"description\":\"call mom\",\"id\":\"t9\",\"priority\":\"high\",\"category\":\"none\",\"complete\":false}";
		assertEquals(expected, entries.get(14).toString());
		JSONObject entry = (JSONObject) entries.get(2);
		assertEquals("walk the dog", entry.get("description"));
		entry = (JSONObject) entries.get(7);
		assertEquals("15 Nov 2015 22:00", entry.get("due date"));
		entry = (JSONObject) entries.get(19);
		assertEquals("none", entry.get("category"));
		entry = (JSONObject) entries.get(0);
		assertEquals(false, entry.get("complete"));
		entry = (JSONObject) entries.get(5);
		assertEquals("low", entry.get("priority"));
		entry = (JSONObject) entries.get(12);
		assertEquals("09 Nov 2015 19:00", entry.get("start date"));
	}
	
	@Test
	public void b_testAddTask(){
		logic.executeUserCommand("add buy milk, november 20 9am, p:high, c:personal");
		//check if an entry is added
		assertEquals(21,entries.size());
		String expected = "{\"due date\":\"20 Nov 2015 09:00\",\"alarm\":\"off\",\"description\":\"buy milk\",\"id\":\"t11\",\"priority\":\"high\",\"category\":\"personal\",\"complete\":false}";
		//check if the added entry is the correct one
		assertEquals(expected, entries.get(20).toString());
	}
	
	
	@Test
	public void c_testAddEvent(){
		logic.executeUserCommand("+ go shopping, Nov 21 3pm to Nov 21 5pm, p:high, c:personal");
		String expected = "{\"start date\":\"21 Nov 2015 15:00\",\"due date\":\"21 Nov 2015 17:00\",\"alarm\":\"off\",\"description\":\"go shopping\",\"id\":\"e11\",\"priority\":\"high\",\"category\":\"personal\",\"complete\":false}";
		assertEquals(22,entries.size());
		assertEquals(expected, entries.get(21).toString());
	}
	
	@Test
	public void d_testDelete(){
		logic.executeUserCommand("delete t8");
		assertEquals(21,entries.size());
		//t8 was originally entries[13]. After its deletion, t9 should now be entries[13].
		String expected = "{\"due date\":\"08 Nov 2015 22:00\",\"alarm\":\"off\",\"description\":\"call mom\",\"id\":\"t9\",\"priority\":\"high\",\"category\":\"none\",\"complete\":false}";
		assertEquals(expected, entries.get(13).toString());
	}
	
	@Test
	public void e_testUndo(){
		logic.executeUserCommand("undo");
		assertEquals(22,entries.size());
		String expected = "{\"due date\":\"11 Nov 2015 12:00\",\"alarm\":\"off\",\"description\":\"submit report\",\"id\":\"t8\",\"priority\":\"high\",\"category\":\"none\",\"complete\":false}";
		//t8 is re-inserted into the JSONArray at the end
		assertEquals(expected, entries.get(21).toString());
	}
	
	@Test
	public void f_testRedo(){
		logic.executeUserCommand("redo");
		assertEquals(21,entries.size());
		String expected = "{\"start date\":\"21 Nov 2015 15:00\",\"due date\":\"21 Nov 2015 17:00\",\"alarm\":\"off\",\"description\":\"go shopping\",\"id\":\"e11\",\"priority\":\"high\",\"category\":\"personal\",\"complete\":false}";
		//t8 is re-deleted, so the last entry should be e11
		assertEquals(expected, entries.get(20).toString());
	}
	
	@Test
	public void g_testUpdate(){
		logic.executeUserCommand("update e1, b:Nov 10 10am");
		//Start date is updated;alarm is also changed since it is set to be 2 hours before the start date
		String expected = "{\"start date\":\"10 Nov 2015 10:00\",\"due date\":\"10 Nov 2015 11:00\",\"alarm\":\"10 Nov 2015 08:00\",\"description\":\"meeting with boss\",\"id\":\"e1\",\"priority\":\"high\",\"category\":\"work\",\"complete\":false}";
		assertEquals(expected, entries.get(0).toString());
	}
	
	@Test
	public void h_testDone(){
		logic.executeUserCommand("done e1");
		String expected = "{\"start date\":\"10 Nov 2015 10:00\",\"due date\":\"10 Nov 2015 11:00\",\"alarm\":\"10 Nov 2015 08:00\",\"description\":\"meeting with boss\",\"id\":\"e1\",\"priority\":\"high\",\"category\":\"work\",\"complete\":\"true\"}";
		assertEquals(expected, entries.get(0).toString());
	}
	
	@Test
	public void i_testCd(){
		logic.executeUserCommand("cd src/test/testFiles/temp");
		File newFile = new File("src/test/testFiles/temp/chronos_storage.txt");
		File oldFile = new File("src/test/testFiles/testSystem/chronos_storage.txt");
		assertTrue(newFile.exists());
		//File at the old directory should have been deleted
		assertFalse(oldFile.exists());
		//Undo cd command so it will be easier for the AfterClass method to clean up
		logic.executeUserCommand("undo");
	}
	
	@Test
	public void j_testNote(){
		logic.executeUserCommand("+note t9, tell her the good news");
		String expected = "{\"due date\":\"08 Nov 2015 22:00\",\"notes\":[{\"note\":\"tell her the good news\"}],\"alarm\":\"off\",\"description\":\"call mom\",\"id\":\"t9\",\"priority\":\"high\",\"category\":\"none\",\"complete\":false}";
		assertEquals(expected, entries.get(13).toString());
	}
	
	@Test
	public void k_testAlarm(){
		logic.executeUserCommand("alarm t11, 1");
		//alarm is set to be 1 hour before the due time
		String expected = "{\"due date\":\"20 Nov 2015 09:00\",\"alarm\":\"20 Nov 2015 08:00\",\"description\":\"buy milk\",\"id\":\"t11\",\"priority\":\"high\",\"category\":\"personal\",\"complete\":false}";
		assertEquals(expected, entries.get(19).toString());
	}
}
```
