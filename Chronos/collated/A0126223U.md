# A0126223U
###### src\application\AddCommand.java
``` java
	@Override
	public Feedback execute() {
		String feedbackString;
		try {
			_store.storeTemp();
			_createdTask = createTaskOrEvent();
			_createdItemID = _createdTask.getId();
			_store.entries_.add(_parse.convertToJSON(_createdTask));
			_isSuccessful = true;
			_store.storeChanges();
			feedbackString = String.format(FEEDBACK_MESSAGE, _content);
			return new Feedback(feedbackString);
		} catch (ArithmeticException e) {
			feedbackString = FEEDBACK_WRONG_END_DATE;
			return new Feedback(feedbackString);
		} catch (NullPointerException e) {
			feedbackString = FEEDBACK_MISSING_DESC;
			return new Feedback(feedbackString);
		} catch (ParseException e) {
			feedbackString = FEEDBACK_WRONG_DATE;
			return new Feedback(feedbackString);
		} 
	}
	
	private Task createTaskOrEvent() throws ParseException, ArithmeticException, NullPointerException {
		Task createdItem = _parse.createItem(_content);
		if (createdItem instanceof Event) {
			createdItem.setId(_store.getEventId());
		} else {
			createdItem.setId(_store.getTaskId());
		} 
		return createdItem;
	}

	@Override
	public Feedback undo() { //edit this
		DeleteCommand undoAdd = new DeleteCommand(_createdItemID);
		if (_createdItemID.contains(Event.ID_HEADER)){
			_store.decreaseEventID();
		} else {
			_store.decreaseTaskID();
		}
		return undoAdd.execute();
	}

	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_DESC);
	    commandInstruction.addToInstructions(INSTRUCTION_OPTIONAL);
		return commandInstruction;
	}
	
}
```
###### src\application\Command.java
``` java
/**
 * This class is used as a format for several Command classes within the package.
 */
public abstract class Command {

	//Messages
	protected static String FEEDBACK_MESSAGE;
		
	protected static final String ERROR_NO_CONTENT = "Error: No content entered.";
	protected static final String ERROR_INVALID_ID = "Error: Invalid ID entered.";
	protected static final String ERROR_NO_ID = "Error: No ID entered.";
		
	protected static final String LOG_NO_ID = "No id specified";
	
	protected static final String EMPTY = "";
	
	public static final int FIND_NO_ID = -2;
	public static final int FIND_INVALID_ID = -1;
	
	//Class Attributes
	protected Storage _store;
	protected Parser _parse;
	protected String _content;
	protected boolean _isSuccessful = false;
	public static Instruction commandInstruction;
	
	protected static Logger log = Logger.getLogger("CommandLog");
	
	public Command(String content) {
		_store = Storage.getInstance();
		_parse = Parser.getInstance();
		_content = content; 
	}
	
	public abstract Feedback execute();
	
	public abstract Feedback undo();
	
	/**
	 * Finds the index of an item in the JSONArray based on its ID.
	 *
	 * @param id   The id of the desired item. Starts with either an 'e' or a 't'.
	 * @return     The index of the item in the Array. Returns -1 if it is not found, or -2 if there is no id passed.
	 */
	public int findEntry (String id) {
		if(id.equals(EMPTY)){
			return FIND_NO_ID;
		} else {
			for (int i = 0; i < _store.entries_.size(); i++) {
				JSONObject currentEntry = (JSONObject) _store.entries_.get(i);
				if (currentEntry.get(Parser.JSON_ID).equals(id)) {
					return i;
				}
			}
			return FIND_INVALID_ID;
		}
	}
	
	public boolean isSuccessful() {
		return _isSuccessful;
	}

}
```
###### src\application\CommandCreator.java
``` java
	Feedback createAndExecuteCommand(String[] inputs) {
		
		COMMAND_TYPE commandType = determineCommandType(inputs[COMMAND_INDEX_COMMAND]);
		String commandContent = getCommandContent(inputs);
		Command aCommand;
		
		switch(commandType) {
		
			case ADD :
			     aCommand = new AddCommand(commandContent);
			     break;
		
			case DELETE :  
				aCommand = new DeleteCommand(commandContent);
				break;
		
			case DISPLAY : 
				aCommand = new DisplayCommand(commandContent);
				break;
			
			case DONE :
				aCommand = new DoneCommand(commandContent);
				break;
				
			case EXTEND :
				aCommand = new ExtendCommand(commandContent);
				break;
			
			case NOTE_ADD : 
				aCommand = new NoteCommand(commandContent);
				break;
				
			case NOTE_DELETE : 
				aCommand = new NoteDeleteCommand(commandContent);
				break;
			
			case NOTE_UPDATE : 
				aCommand = new NoteUpdateCommand(commandContent);
				break;

			case UPDATE :
				aCommand = new UpdateCommand(commandContent);
				break;
		
			case SEARCH :
				aCommand = new SearchCommand(commandContent);
				break;
		
			case VIEW :
				aCommand = new ViewCommand(commandContent);
				break;
			
			case UNDO :
				return undoLatestCommand();
				//break;
			
			case REDO :
				return redoCommand();
				//break;
			
			case CD :
				aCommand = new DirectoryCommand(commandContent);
				break;
			
			case EXIT : 
				aCommand = new ExitCommand(commandContent);
				break;
				
			case ALARM:
				aCommand = new AlarmCommand(commandContent);
				break;
				
			case UNKNOWN : 
				//Fallthrough
				
			default :
				aCommand = new UnknownCommand(commandContent);
				break;
		}
		
		if (!(aCommand instanceof UnknownCommand)) {
			String commandString = inputs[COMMAND_INDEX_COMMAND] + " " +commandContent;
			_typedCommandStrings.add(commandString);
		}
		
		Feedback feedback = aCommand.execute();
		updateStacks(aCommand);
		return feedback;
	}
	
	private void updateStacks(Command aCommand) {
		if(aCommand.isSuccessful()) {
			_pastCommands.push(aCommand);
			_undoneCommands.clear();
		}
	}

	private Feedback redoCommand() {
		try {
			Command latestCommand = _undoneCommands.pop();
			_pastCommands.push(latestCommand);
			return latestCommand.execute();
		} catch (EmptyStackException e) {
			return new Feedback(ERROR_NO_REDO);
		}
	}

	private Feedback undoLatestCommand() {
		try {
			Command latestCommand = _pastCommands.pop();
			_undoneCommands.push(latestCommand);
			return latestCommand.undo();
		} catch (EmptyStackException e) {
			return new Feedback(ERROR_NO_UNDO);
		}
	}

	private String getCommandContent(String[] inputs) {
		try {
			return inputs[COMMAND_INDEX_CONTENT];
		} catch (ArrayIndexOutOfBoundsException e) {
			return CONTENT_EMPTY;
		}
	}

	private static COMMAND_TYPE determineCommandType(String typeString) {
		
		switch(typeString.toLowerCase()) {
			
			case COMMAND_ADD_PLUS :
				//Fallthrough
			
			case COMMAND_ADD_ADD :
				return COMMAND_TYPE.ADD;
				//break;
			
			case COMMAND_CD :
				return COMMAND_TYPE.CD;
				//break;
			
			case COMMAND_DELETE_MINUS :
				//Fallthrough	
			
			case COMMAND_DELETE :
				return COMMAND_TYPE.DELETE;
				//break;
			
			case COMMAND_DISPLAY_D :
				//Fallthrough
				
			case COMMAND_DISPLAY_ALL :
				return COMMAND_TYPE.DISPLAY;
				//break;
			
			case COMMAND_DONE : 
				return COMMAND_TYPE.DONE;
				//break;
				
			case COMMAND_EXIT : 
				return COMMAND_TYPE.EXIT;
				//break;
				
			case COMMAND_EXTEND : 
				return COMMAND_TYPE.EXTEND;
				//break;
			
			case COMMAND_NOTE_ADD : 
				return COMMAND_TYPE.NOTE_ADD;
				//break;
				
			case COMMAND_NOTE_DELETE : 
				return COMMAND_TYPE.NOTE_DELETE;
				//break;
			
			case COMMAND_NOTE_UPDATE : 
				return COMMAND_TYPE.NOTE_UPDATE;
				//break;
			
			case COMMAND_REDO_ARROW :
				//Fallthrough	
				
			case COMMAND_REDO : 
				return COMMAND_TYPE.REDO;
				//break;
			
			case COMMAND_SEACH_QUESTION :
				//Fallthrough	
				
			case COMMAND_SEARCH : 
				return COMMAND_TYPE.SEARCH;
				//break;
				
			case COMMAND_UNDO_ARROW :
				//Fallthrough		
				
			case COMMAND_UNDO : 
				return COMMAND_TYPE.UNDO;
				//break;
			
			case COMMAND_UPDATE_U :
				//Fallthrough		
				
			case COMMAND_UPDATE : 
				return COMMAND_TYPE.UPDATE;
				//break;
			
			case COMMAND_VIEW : 
				return COMMAND_TYPE.VIEW;
				//break;
				
			case COMMAND_ALARM:
				return COMMAND_TYPE.ALARM;
				
			default : 
				return COMMAND_TYPE.UNKNOWN;
				//break;
		}
	}

	public Feedback executeInitializeCommand(String path) {
		return new InitializeCommand(path).execute();
	}

	public static Instruction generateInstructions(String commandString) {
		COMMAND_TYPE commandType = determineCommandType(commandString);
		Instruction commandInstruction = new Instruction();
		switch (commandType) {
			
			case ADD :
			     commandInstruction = AddCommand.generateInstruction();
			     break;
		
			case DELETE : 
				 commandInstruction = DeleteCommand.generateInstruction();
				 break;
		
			case DISPLAY : 
				 commandInstruction = DisplayCommand.generateInstruction();
				 break;
			
			case DONE : 
				 commandInstruction = DoneCommand.generateInstruction();
				 break;
			
			case EXTEND : 
				 commandInstruction = ExtendCommand.generateInstruction();
				 break;
			
			case NOTE_ADD : 
				 commandInstruction = NoteCommand.generateInstruction();
				 break;
				 
			case NOTE_UPDATE : 
				 commandInstruction = NoteUpdateCommand.generateInstruction();
				 break;
			
			case NOTE_DELETE : 
				 commandInstruction = NoteDeleteCommand.generateInstruction();
				 break;
	
			case UPDATE :
				 commandInstruction = UpdateCommand.generateInstruction();
				 break;
		
			case SEARCH :
				 commandInstruction = SearchCommand.generateInstruction();
				 break;
		
			case VIEW :
				 commandInstruction = ViewCommand.generateInstruction();
				 break;
			
			case UNDO :
				 commandInstruction.setCommandPattern(String.format(PATTERN_UNDO, _pastCommands.size()));
				 break;
			
			case REDO :
				 commandInstruction.setCommandPattern(String.format(PATTERN_REDO, _undoneCommands.size()));
				 break;
			
			case CD :
				 commandInstruction = DirectoryCommand.generateInstruction();
				 break;
			
			case EXIT : 
				 commandInstruction.setCommandPattern(PATTERN_EXIT);
				 break;
				 
			case ALARM:
				 commandInstruction.setCommandPattern(PATTERN_ALARM);
				 break;
		
			case UNKNOWN : 
				//Fallthrough
				
			default :
				 commandInstruction.setCommandPattern(PATTERN_UNKNOWN);
				 break;
		}
		
		return commandInstruction;
	}
	
	public static String getTypedCommandString(int commandIndex) {
		try {
			return _typedCommandStrings.get(_typedCommandStrings.size()-commandIndex);
		} catch (IndexOutOfBoundsException e) {
			return null;
		}
	}

	public static boolean isWithinRange(int _commandIndex) {
		int itemIndex = _typedCommandStrings.size() - _commandIndex;
		return (itemIndex >= 0) && (itemIndex < _typedCommandStrings.size());
	}

	public Feedback executeGUIDisplayCommand() {
		GUIDisplayCommand aCommand = new GUIDisplayCommand();
		return aCommand.execute();
	}
	
}
```
###### src\application\DeleteCommand.java
``` java
	@Override
	public Feedback execute() {
		String feedbackString = null;
		if (_content != EMPTY) {
			_store.storeTemp();
			feedbackString = deleteItem(); 
			_store.storeChanges();
		} else {
			assert _content == null;
			log.warning(LOG_NO_ID);
		}
		return new Feedback(feedbackString); 
	}

	private String deleteItem() {
		int itemIndex = findEntry(_content);
		if(itemIndex == Command.FIND_NO_ID) {
			return ERROR_NO_ID;
		} else if (itemIndex == Command.FIND_INVALID_ID) {
			return ERROR_INVALID_ID;
		} else {
			_deletedEntry = (JSONObject) _store.entries_.remove(itemIndex);
			_isSuccessful = true;
			return String.format(FEEDBACK_MESSAGE, _content);
		}
	}
	
	@Override
	public Feedback undo() {
		_store.storeTemp();
		_store.entries_.add(_deletedEntry);
		_store.storeChanges();
		String feedbackString = String.format(FEEDBACK_MESSAGE_UNDO, _content);
		return new Feedback(feedbackString);
	}
	
	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_ID);
		return commandInstruction;
	}

}
```
###### src\application\DoneCommand.java
``` java
	@Override
	public Feedback execute() {
		int index = findEntry(_content);
		if (index == Command.FIND_NO_ID) {
			assert _content.equals(EMPTY);
			log.warning(LOG_NO_ID);
			return new Feedback(ERROR_NO_ID);
		} else if (index == Command.FIND_INVALID_ID) {
			return new Feedback(ERROR_INVALID_ID);
		} else {
			String feedbackString = String.format(FEEDBACK_MESSAGE, _content);
			_completedTask = _parse.retrieveTask(_content, _store.entries_);
			if (_completedTask.isTaskComplete()) {
				return new Feedback(String.format(FEEDBACK_ALREADY_DONE, _content));
			} else {
				_completedTask.markTaskAsDone(true);
				String content = _completedTask.getId() + UPDATE_STRING + _completedTask.isTaskComplete();
				Feedback feedback = new UpdateCommand(content).execute();
				_isSuccessful = true;
				feedback.setMessage(feedbackString);
				return feedback;
			}
		}
	}

	@Override
	public Feedback undo() {
		_completedTask.markTaskAsDone(false); 
		String content = _completedTask.getId() + UPDATE_STRING + _completedTask.isTaskComplete();
		Feedback feedback = new UpdateCommand(content).execute();
		return feedback;
	}
	
	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_ID);
		return commandInstruction;
	}
	
	
}
```
###### src\application\Event.java
``` java
	public Event(String[] contents) throws ArithmeticException, ParseException {
		super();
		_description = contents[0];
		for (int i = 1; i < contents.length; i++) {
			if (contents[i].contains(PRIORITY_HEADER)) {
				_priority = contents[i].substring(2).toLowerCase();
			} else if (contents[i].contains(CATEGORY_HEADER)) {
				_category = contents[i].substring(2);
			} else { //date manipulation
				String[] dates = contents[i].split(DATE_SEPARATOR);
				Calendar start = Chronic.parse(dates[0]).getBeginCalendar();
				Calendar end = Chronic.parse(dates[1]).getEndCalendar();
				if (end.getTime().compareTo(start.getTime())<0){
					throw new ArithmeticException(MESSAGE_INVALID_END);
				}
				_startDate = manipulateDate(start);
				_endDate = manipulateDate(end);
			}
		}
	}
	
	public Event(String id, String description, String startDate, String endDate, String priority, String category, String alarm) {
		_id = id;
		_description = description;
		_startDate = startDate;
		_endDate = endDate;
		_priority = priority;
		_category = category;
		_alarm = alarm;
	}

	public Task toTask(int id) { //get id from storage
		return new Task(id, _description, _endDate, _priority, _category, _alarm);
	}
	
	@Override
	public String toString(){
		return  _id + ID_DISPLAY + _description + EMPTY_SPACE + _startDate+ DATE_SEPARATOR + _endDate + EMPTY_SPACE + _priority + EMPTY_SPACE + _category;
	}
	
	@Override
	public String getAlarmOffset(){
		return _startDate;
	}
	
	public String getStartDate() {
		return _startDate;
	}

	void setStartDate(String startDate) {
		_startDate = startDate.trim();
	}
	
	void setId(int id) {
		_id = ID_HEADER + Integer.toString(id);
	}

}
```
###### src\application\ExtendCommand.java
``` java
	@Override
	public Feedback execute() { 
		ArrayList<String> extendDetails = _parse.parseExtendString(_content);
		String taskID = extendDetails.remove(0);
		_index = findEntry(taskID);
		
		if (_index == Command.FIND_NO_ID) {
			assert _content.equals(EMPTY);
			log.warning(LOG_NO_ID);
			return new Feedback(ERROR_NO_ID);
		} else if (_index == Command.FIND_INVALID_ID) {
			return new Feedback(ERROR_INVALID_ID);
		} else {
			if (extendDetails.size() == 0) {
				return new Feedback(ERROR_NO_EXTENSION);
			} else { 
				JSONObject entry = (JSONObject) _store.entries_.get(_index);
				_oldEntry = (JSONObject) entry.clone();
				if(_oldEntry.get(JSON_END_DATE).equals("someday")) {
					return new Feedback(ERROR_CANT_EXTEND);
				} else { 
					_store.storeTemp();
					Task taskToExtend = extendTask(taskID, extendDetails);
					_store.entries_.set(_index, _parse.convertToJSON(taskToExtend));
					_store.storeChanges();
					_isSuccessful = true;
					String feedbackString = String.format(FEEDBACK_MESSAGE, _content);
					return new Feedback(feedbackString);
				}
			}
		}
	}

	private Task extendTask(String taskID, ArrayList<String> extendDetails) {
		Task taskToExtend = _parse.retrieveTask(taskID, _store.entries_);
		if(extendDetails.size()==1 && extendDetails.get(0).equals("someday")) {
			taskToExtend.setEndDate("someday");
		} else {
			Calendar endDate = Calendar.getInstance();
			endDate.setTime(getTaskEndDate(taskToExtend));
			for(String extendDetail:extendDetails){
				String[] details = extendDetail.split(":");
				int field = determineField(details[0]);
				int amount = Integer.parseInt(details[1]); //amount should be >0
				if(field > 0) {
					endDate.add(field, amount);
				}
			}
			DateFormat dateFormat = new SimpleDateFormat(Task.DATE_FORMAT);
			taskToExtend.setEndDate(dateFormat.format(endDate.getTime()));
		}
		return taskToExtend;
	}

	private int determineField(String string) {
		switch(string) {
		
			case FIELD_YEAR :
			     return Calendar.YEAR;
			     //break;
			     
			case FIELD_MONTH :
				 return Calendar.MONTH;
				 //break;
			
			case FIELD_DAY :
				 return Calendar.DATE;
				 //break;
			
			case FIELD_HOUR :
				 return Calendar.HOUR;
				 //break;
			
			case FIELD_MIN :
				 return Calendar.MINUTE;
				 //break;
			
			default :
				return -1;
		}
	}

	private Date getTaskEndDate(Task taskToExtend) {
		DateFormat dateFormat = new SimpleDateFormat(Task.DATE_FORMAT);
		try {
			return dateFormat.parse(taskToExtend.getEndDate());
		} catch (ParseException e) {
			return null;
		}
	}
	
	@Override
	public Feedback undo() {
		_store.storeTemp();
		JSONObject entry = (JSONObject) _store.entries_.get(_index);
		_store.entries_.set(_index, _oldEntry);
		_store.storeChanges();
		String feedbackString = String.format(FEEDBACK_MESSAGE_UNDO, _content);
		return new Feedback(feedbackString);
	}

	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_TASK);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_ID);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_DEADLINE);
		commandInstruction.addToRequiredFields(REQUIRED_FIELD_DEADLINE);
		return commandInstruction;
	}
	
	
	
}
```
###### src\application\Feedback.java
``` java
/**
 * This class is for communication between the GUI and Logic classes.
 * It contains a String and data (ArrayList<Task>). 
 * It will be returned whenever Logic executes the following methods:
 * 	- executeUserCommand()
 *  - setSavePath()
 */
public class Feedback {

	private String _feedbackString;
	private ArrayList<Task> _taskData;
	private boolean _hasData;
	private boolean _isExiting = false;
	private boolean _isInSummaryView = true;

	public Feedback() {
		_isExiting = true;
	}
	
	public Feedback(String feedback) {
		_feedbackString = feedback;
		_hasData = false;
		_taskData = new ArrayList<Task>();
	}
	
	public Feedback(String feedback, ArrayList<Task> data) {
		_feedbackString = feedback;
		_taskData = data;
		_hasData = true;
	}
	
	public String getMessage() {
		return _feedbackString;
	}
	
	public void setMessage(String feedbackString) {
		_feedbackString = feedbackString;
	}
	
	public ArrayList<Task> getData() {
		return _taskData;
	}
	
	public boolean hasData(){
		return _hasData;
	}

	public boolean isProgramExiting() {
		return _isExiting;
	}
	
	void setProgramExiting(boolean isExiting) {
		_isExiting = isExiting;
	}

	public boolean isInSummaryView() {
		return _isInSummaryView;
	}
	
	void setSummaryView(boolean isInSummaryView) {
		_isInSummaryView = isInSummaryView;
	}
	
	public String toString(){
		return _taskData.toString();
	}
}
```
###### src\application\Instruction.java
``` java
public class Instruction {

	private int _numberOfSteps = 0;
	private ArrayList<String> _instructions;
	private ArrayList<String> _requiredFields;
	private ArrayList<String> _optionalFields; 
	private String _commandPattern;	
	
	public Instruction() {
		_instructions = new ArrayList<String>();
		_requiredFields = new ArrayList<String>();
	}
	
	public void addToRequiredFields(String fieldString) {
		_requiredFields.add(fieldString);
	}
	
	public void addToInstructions(String instructionString) {
		_instructions.add(instructionString);
	}
	
	public void nextStep() {
		if(_numberOfSteps < _instructions.size()) { 
			_numberOfSteps++;
		} 
	}
	
	public void previousStep() {
		if(_numberOfSteps >= 0) {
			_numberOfSteps--;
		}
	}
	
	public boolean isFinished() {
		return _numberOfSteps == _instructions.size();
	}
	
	public String getNextInstruction() {
			return _instructions.get(_numberOfSteps);
	}
	
	public String getNextRequiredField() {
		try {
			return _requiredFields.get(_numberOfSteps);
		} catch (IndexOutOfBoundsException e) {
			return Command.EMPTY;
		}
	}
	
	public void setCommandPattern (String commandPattern) {
		_commandPattern = commandPattern;
	}
	
	public String getCommandPattern () {
		return _commandPattern;
	}

	public boolean hasInstructions() {
		return _instructions.size() > 0;
	}
	
	
}
```
###### src\application\Logic.java
``` java
public class Logic {
	
	private static CommandCreator _commandCreator;
	private static Storage _store;
	private static Parser _parse;
	private static Logic _theLogic = null;
	private static final String ALARM_OFF = "off";
	private static final String ALARM_OFF_COMMAND = "alarm %1$s, off";
	private static final int INDEX_DEFAULT = 0;
	private static int _commandIndex;
	
	private Logic(){
		_commandCreator = new CommandCreator();
	}
	
	public static Logic getInstance() {
		if (_theLogic == null) {
			_theLogic = new Logic();
			_commandIndex = INDEX_DEFAULT;
		}
		return _theLogic;
	}
	
	public boolean isSavePresent() {
		_store = Storage.getInstance();
		_parse = Parser.getInstance();
		return _store.checkIsSavePresent();
	}
	
	//happens if there's no save present
	public Feedback setSavePath(String path) { 
		return _commandCreator.executeInitializeCommand(path);
	}
	
	public Feedback executeUserCommand(String userInput) {
		String[] inputs = _parse.parseUserContent(userInput);
		return _commandCreator.createAndExecuteCommand(inputs);
	}
	
	public boolean checkForClashes(Task taskToCheck) {
		return _parse.checkForClashes(taskToCheck, _store.entries_);
	}

	public static Instruction getCommandInstruction(String commandString) {
		return CommandCreator.generateInstructions(commandString);
	}
	
	public String getAlarmOffset(Task aTask){
		return aTask.getAlarmOffset();
	}
	
	public void switchOffAlarm(Task aTask){
		aTask.setAlarm(ALARM_OFF);
		String id = aTask.getId();
		executeUserCommand(String.format(ALARM_OFF_COMMAND, id));
	}
	
	public static String getPreviouslyTypedCommand() {
		_commandIndex++;
		if(CommandCreator.isWithinRange(_commandIndex)) {
			return CommandCreator.getTypedCommandString(_commandIndex);
		} else {
			_commandIndex--;
			return CommandCreator.getTypedCommandString(_commandIndex);
		}
	}

	public static String getNextTypedCommand() {
		_commandIndex--;
		if(CommandCreator.isWithinRange(_commandIndex)) {
			return CommandCreator.getTypedCommandString(_commandIndex);
		} else {
			_commandIndex++;
			return CommandCreator.getTypedCommandString(_commandIndex);
		}
	}
	
	public Feedback updateDisplay() {
		return _commandCreator.executeGUIDisplayCommand();
	}
}
```
###### src\application\Note.java
``` java
public class Note {
	
	private String _content = Command.EMPTY;
	
	public Note(String content) {
		_content = content;
	} 
	
	public String toString(){
		return _content;
	}
}
```
###### src\application\NoteCommand.java
``` java
	@Override
	public Feedback execute() {
		String feedbackString = EMPTY;
		String[] noteDetails = _content.split(Parser.CONTENT_SEPARATOR);
		
		_index = findEntry(noteDetails[0]);
		if (_index == Command.FIND_NO_ID) {
			assert _content.equals(EMPTY);
			log.warning(LOG_NO_ID);
			return new Feedback(ERROR_NO_ID);
		} else if (_index == Command.FIND_INVALID_ID) {
			return new Feedback(ERROR_INVALID_ID);
		} else {
			if (noteDetails[1].equals(EMPTY)){
				return new Feedback(ERROR_NO_CONTENT);
			} else {
				JSONObject entry = (JSONObject)_store.entries_.get(_index);
				_oldEntry = (JSONObject) entry.clone();
				return noteProcess(_index, noteDetails);				
			}
		}
	}
	
	private Feedback noteProcess(int id, String[] noteDetails) {
		_store.storeTemp();
		Task aTask = _parse.retrieveTask(noteDetails[0], _store.entries_);
		aTask.addNote(noteDetails[1]); 
		_store.entries_.set(_index, _parse.convertToJSON(aTask));
		_store.storeChanges();
		
		_isSuccessful = true;
		String feedbackString = String.format(FEEDBACK_MESSAGE, _content);
		ArrayList<Task> feedbackData = new ArrayList<Task>();
		feedbackData.add(aTask);
		
		Feedback feedback = new Feedback(feedbackString, feedbackData);
		feedback.setSummaryView(false);
		return feedback;
	}

	@Override
	public Feedback undo() {
		_store.storeTemp();
		JSONObject entry = (JSONObject) _store.entries_.get(_index);
		_store.entries_.set(_index, _oldEntry);
		_store.storeChanges();
		String feedbackString = String.format(FEEDBACK_MESSAGE_UNDO, _content);
		return new Feedback(feedbackString);
	}
	
	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_TASK);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_ID);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_NOTE);
		commandInstruction.addToRequiredFields(REQUIRED_FIELD_NOTE);
		return commandInstruction;
	}
	
}
```
###### src\application\NoteDeleteCommand.java
``` java
	@Override
	public Feedback execute() {
		String[] noteDetails = _content.split(Parser.CONTENT_SEPARATOR);
		
		_index = findEntry(noteDetails[0]);
		if (_index == Command.FIND_NO_ID) {
			assert _content.equals(EMPTY);
			log.warning(LOG_NO_ID);
			return new Feedback(ERROR_NO_ID);
		} else if (_index == Command.FIND_INVALID_ID) {
			return new Feedback(ERROR_INVALID_ID);
		} else {
			if (noteDetails.length == 1 || noteDetails[1].equals(EMPTY)){
				return new Feedback(ERROR_NO_NOTE_ID);
			} else {
				JSONObject entry = (JSONObject)_store.entries_.get(_index);
				_oldEntry = (JSONObject) entry.clone();
				return deleteNote(_index, noteDetails);				
			}
		}
	}

	private Feedback deleteNote(int itemID, String[] noteDetails) {
		
		Task aTask = _parse.retrieveTask(noteDetails[0], _store.entries_);
	
		int noteID = Integer.parseInt(noteDetails[1]);
		if (aTask.hasNote(noteID)) {
			_store.storeTemp();
			aTask.deleteNote(noteID);
			_store.entries_.set(_index, _parse.convertToJSON(aTask));
			_store.storeChanges();
			
			_isSuccessful = true;
			String feedbackString = String.format(FEEDBACK_MESSAGE, _content);
			ArrayList<Task> feedbackData = new ArrayList<Task>();
			feedbackData.add(aTask);
			
			Feedback feedback = new Feedback(feedbackString, feedbackData);
			feedback.setSummaryView(false);
			return feedback;
		} else {
			return new Feedback(ERROR_INVALID_NOTE_ID);
		}
		
	}
	
	@Override
	public Feedback undo() {
		_store.storeTemp();
		JSONObject entry = (JSONObject) _store.entries_.get(_index);
		_store.entries_.set(_index, _oldEntry);
		_store.storeChanges();
		String feedbackString = String.format(FEEDBACK_MESSAGE_UNDO, _content);
		ArrayList<Task> feedbackData = new ArrayList<Task>();
		Task aTask = _parse.convertToTask(entry);
		feedbackData.add(aTask);
		Feedback feedback =  new Feedback(feedbackString);
		feedback.setSummaryView(false);
		return feedback;
	}

	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_TASK);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_ID);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_NOTE);
		commandInstruction.addToRequiredFields(REQUIRED_FIELD_NOTE);
		return commandInstruction;
	}

}
```
###### src\application\NoteUpdateCommand.java
``` java
	@Override
	public Feedback execute() {
		String[] noteDetails = _content.split(Parser.CONTENT_SEPARATOR);
		
		_index = findEntry(noteDetails[0]);
		if (_index == Command.FIND_NO_ID) {
			assert _content.equals(EMPTY);
			log.warning(LOG_NO_ID);
			return new Feedback(ERROR_NO_ID);
		} else if (_index == Command.FIND_INVALID_ID) {
			return new Feedback(ERROR_INVALID_ID);
		} else {
			if (noteDetails.length == 1 || noteDetails[1].equals(EMPTY)){
				return new Feedback(ERROR_NO_NOTE_ID);
			} else if (noteDetails.length == 2 || noteDetails[2].equals(EMPTY)) {
				return new Feedback(ERROR_NO_NOTE_CONTENT);
			} else {
				JSONObject entry = (JSONObject)_store.entries_.get(_index);
				_oldEntry = (JSONObject) entry.clone();
				return updateNote(_index, noteDetails);				
			}
		}
	}
	
	private Feedback updateNote(int itemID, String[] noteDetails) {
		
		Task aTask = _parse.retrieveTask(noteDetails[0], _store.entries_);
	
		int noteID = Integer.parseInt(noteDetails[1]);
		if (aTask.hasNote(noteID)) {
			_store.storeTemp();
			aTask.updateNote(noteID, noteDetails[2]);
			_store.entries_.set(_index, _parse.convertToJSON(aTask));
			_store.storeChanges();
			
			_isSuccessful = true;
			String feedbackString = String.format(FEEDBACK_MESSAGE, _content);
			ArrayList<Task> feedbackData = new ArrayList<Task>();
			feedbackData.add(aTask);
			
			Feedback feedback = new Feedback(feedbackString, feedbackData);
			feedback.setSummaryView(false);
			return feedback;
		} else {
			return new Feedback(ERROR_INVALID_NOTE_ID);
		}
		
	}

	@Override
	public Feedback undo() {
		_store.storeTemp();
		JSONObject entry = (JSONObject) _store.entries_.get(_index);
		_store.entries_.set(_index, _oldEntry);
		_store.storeChanges();
		String feedbackString = String.format(FEEDBACK_MESSAGE_UNDO, _content);
		ArrayList<Task> feedbackData = new ArrayList<Task>();
		Task aTask = _parse.convertToTask(entry);
		feedbackData.add(aTask);
		Feedback feedback =  new Feedback(feedbackString);
		feedback.setSummaryView(false);
		return feedback;
	}

	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_TASK);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_ID);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_NOTE_ID);
		commandInstruction.addToRequiredFields(REQUIRED_FIELD_NOTE_ID);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED_NOTE);
		commandInstruction.addToRequiredFields(REQUIRED_FIELD_NOTE);
		return commandInstruction;
	}

}
```
###### src\application\SearchCommand.java
``` java
	@Override
	public Feedback execute() {
		ArrayList<Task> filteredTasks = new ArrayList<Task>();
		String[] searchCriteria = _parse.getContentArray(_content);
		for (int i = 0; i < _store.entries_.size(); i++) {
			String entry = _store.entries_.get(i).toString();
			JSONObject entryObject = (JSONObject) _store.entries_.get(i);
			Task entryItem = _parse.convertToTask(entryObject);
			if (isMatchingEntry(entryItem, searchCriteria)) {
			    filteredTasks.add(_parse.retrieveTask(entryObject.get(_parse.JSON_ID).toString(),_store.entries_));
			}
		}
		String feedbackString = String.format(FEEDBACK_MESSAGE, _content);
		return new Feedback(feedbackString, filteredTasks); 
	}

	private boolean isMatchingEntry(Task entryItem, String[] searchCriteria) {
		if (entryItem.getDescription().contains(searchCriteria[0]) && !searchCriteria[0].equals("*")) {
			return true;
		}
		for (int i = 1; i < searchCriteria.length; i++) {
			if (searchCriteria[i].contains(PRIORITY_HEADER)) {
				return entryItem.getPriority().equals(searchCriteria[i].substring(2));
			} else if (searchCriteria[i].contains(CATEGORY_HEADER)) {
				return entryItem.getCategory().contains(searchCriteria[i].substring(2));
			} else { 
				try {
					return searchDates(searchCriteria[i], entryItem);
				} catch (ParseException e) {
					return false;
				}
			}
		}
		return false;
	}

	private boolean searchDates(String dateString, Task entryItem) throws ParseException {		
		DateFormat dateFormat = new SimpleDateFormat(Task.DATE_FORMAT);
		if (dateString.equalsIgnoreCase(entryItem.DEFAULT_END_DATE)) {
			return dateString.equals(entryItem.getEndDate());
		} else {
			if(entryItem.getEndDate().equals(entryItem.DEFAULT_END_DATE)) {
				return false;
			} else { 
				Calendar searchEndDate = Chronic.parse(dateString).getBeginCalendar();
				Calendar endDate = Calendar.getInstance();
				endDate.setTime(dateFormat.parse(entryItem.getEndDate()));
				if (isSameDay(searchEndDate, endDate)) {
					return true;
				} else if (entryItem instanceof Event) {
					Calendar startDate = Calendar.getInstance();
					startDate.setTime(dateFormat.parse(((Event) entryItem).getStartDate()));
					//Calendar startDate = Chronic.parse(((Event) entryItem).getStartDate()).getBeginCalendar();
					return isSameDay(searchEndDate, startDate);
				} else {
					return false;
				}
			}
			
		}
	}

	private boolean isSameDay(Calendar date1, Calendar date2) {
		return (date1.get(Calendar.YEAR) == date2.get(Calendar.YEAR)) && (date1.get(Calendar.DAY_OF_YEAR) == date2.get(Calendar.DAY_OF_YEAR));
	}

	@Override
	public Feedback undo() {
		return null;
	}
	
	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_SEARCH);
	    commandInstruction.addToInstructions(INSTRUCTION_OPTIONAL);
		return commandInstruction;
	}
	
}
```
###### src\application\Task.java
``` java
public class Task {
	
	String DEFAULT_END_DATE = "someday";
	String DEFAULT_PRIORITY = "low";
	String DEFAULT_CATEGORY = "none";
	String DEFAULT_STATUS = "false";
	String DEFAULT_ALARM = "off";
	static final String ID_HEADER = "t";	
	public static final String DATE_FORMAT = "dd MMM yyyy HH:mm";
	
	protected String _id;
	protected String _description;
	protected String _endDate = DEFAULT_END_DATE;
	protected String _priority = DEFAULT_PRIORITY;
	protected String _category = DEFAULT_CATEGORY;
	protected String _alarm = DEFAULT_ALARM;
	protected String _status = DEFAULT_STATUS;
	protected boolean _isDone = false;
	protected boolean _isClashing = false;
	protected ArrayList<Note> _notes = new ArrayList<Note>();
	
	DateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT); 
	
	protected Task() {
		
	}
	
	public Task(String[] contents) throws ParseException {
		_description = contents[0];
		for (int i = 1; i<contents.length; i++) {
			if (contents[i].contains("p:")) {
				_priority = contents[i].substring(2).toLowerCase();
			} else if (contents[i].contains("c:")) {
				_category = contents[i].substring(2);
			} else { //date manipulation
				Span aSpan = Chronic.parse(contents[i]);
				if(aSpan == null) {
					throw new ParseException("JChronic unable to parse",0);
				} else {
					_endDate = manipulateDate(aSpan.getBeginCalendar());
				}
			}
		}
	}
	
	protected String manipulateDate(Calendar theDate) throws ParseException {	
		return dateFormat.format(theDate.getTime());
	}

	public Task(int id, String description, String endDate, String priority, String category, String alarm) {
		_id = ID_HEADER + Integer.toString(id);
		_description = description.trim();
		if(!endDate.equals(null)){
			setEndDate(endDate);
		}
		if(!priority.equals(null)){
			setPriority(priority);
		}
		if(!category.equals(null)){
			setCategory(category);
		}
		if(!alarm.equals(null)){
			setAlarm(alarm);
		}
	}
	
	public Task(String id, String description, String endDate, String priority, String category, String alarm) {
		_id = id.trim();
		_description = description.trim();
		if(!endDate.equals(null)){
			setEndDate(endDate);
		}
		if(!priority.equals(null)){
			setPriority(priority);
		}
		if(!category.equals(null)){
			setCategory(category);
		}
		if(!alarm.equals(null)){
			setAlarm(alarm);
		}
	}

	public String getId() {
		return _id;
	}
	
	void setId(int id) {
		_id = ID_HEADER + Integer.toString(id);
	}
	
	public String getDescription() {
		return _description;
	}

	void setDescription(String description) {
		_description = description;
	}

	public String getEndDate() {
		return _endDate;
	}

	void setEndDate(String endDate) {
		_endDate = endDate.trim();
	}

	public String getPriority() {
		return _priority;
	}
	
	void setPriority(String priority) {
		_priority = priority.trim();
	}
	
	public String getStatus(){
		return _status;
	}

	public String getCategory() {
		return _category;
	}

	void setCategory(String category) {
		_category = category.trim();
	}
	
	public int getNotesNo() {
		try{
			return _notes.size();
		} catch (NullPointerException e) {
			return 0;
		}
	}
	
	public String getAlarm(){
		return _alarm;
	}
	
	public void setAlarm(String alarm){
		_alarm = alarm;
	}
	
	public boolean hasAlarm(){
		if (_alarm.equals(DEFAULT_ALARM)){
			return false;
		}else{
			return true;
		}
	}
	
	public String getAlarmOffset(){
		return _endDate;
	}
	
	public Date getAlarmDate(){
		assert(!_alarm.equals(DEFAULT_ALARM));
		try {
			return dateFormat.parse(_alarm);
		} catch (ParseException e) {
			return null;
		}
	}
	@Override
	public String toString() {

		return _id + ". " + _description + " " + _endDate + " "+ _alarm+" "+ _priority + " " + _category+" "+_isDone;

	}
	
	public boolean isTaskComplete() {
		return _isDone;
	}
	
	public void markTaskAsDone(boolean status) {
		_isDone = status;
	}
	
	public void addNote(String noteString){
			_notes.add(new Note(noteString));
	}
	
	//for detailed view
	public ArrayList<String> getNotes(){
		ArrayList<String> notes = new ArrayList<String>();
		for(int i=0; i<_notes.size(); i++){
			notes.add(_notes.get(i).toString());
		}		
		return notes;
	}

	public Task copy() {
		Task copiedTask = new Task(_id, _description, _endDate, _priority, _category, _alarm);
		for(Note aNote:_notes){
			copiedTask.addNote(aNote.toString());
		}
		return copiedTask;
	}
	
	public boolean isOverdue() {
		try {
			Date dueDate;
			Date currentDate = new Date();
			if(_endDate.toLowerCase().contains(":")) { //if deadline has a specified time
				dueDate = dateFormat.parse(_endDate);
			} else { //if deadline has no specified time: put it at 11:59:59
				dueDate = dateFormat.parse(_endDate);
				Calendar endDate = Calendar.getInstance();
				endDate.setTime(dueDate);
				endDate.set(Calendar.HOUR_OF_DAY, 23);
				endDate.set(Calendar.MINUTE, 59);
				endDate.set(Calendar.SECOND, 59);
				dueDate = endDate.getTime();
			}
			return (dueDate.compareTo(currentDate) < 0);
		} catch (ParseException e) {
			//Case: Someday
			return false;
		}
	}
	
	void setClashing(boolean isClashing) {
		_isClashing = isClashing;
	}
	
	public boolean isClashing() {
		return _isClashing;
	}

	public boolean hasNote(int noteID) {
		if(_notes.isEmpty()) {
			return false;
		} else if (noteID > 0 && noteID <= _notes.size() ) {
			return true;
		} else {
			return false;
		}
	}

	public void deleteNote(int noteID) {
		_notes.remove(noteID - 1);
	}

	public void updateNote(int noteID, String string) {
		_notes.set(noteID, new Note(string));		
	}
}
```
###### src\application\TaskComparator.java
``` java
public class TaskComparator implements Comparator<Task> {
	
	private static final String DEFAULT_END_DATE = "someday";
	private static final String PRIORITY_HIGH = "high";
	private static final String PRIORITY_MED = "med";
	private static final String PRIORITY_LOW = "low";

	@Override
	public int compare(Task task1, Task task2) {
		if (!task1.isTaskComplete() && task2.isTaskComplete()) {
			return -1;
		} else if (task1.isTaskComplete() && !task2.isTaskComplete()) {
			return 1;
		} else {
			if((task1 instanceof Event) && !(task2 instanceof Event)) {
				return -1;
			} else if (!(task1 instanceof Event) && (task2 instanceof Event)) {
				return 1;
			} else {
				return compareDeadline(task1, task2);
			}
		}
	}
	
	private int compareDeadline(Task task1, Task task2) {
		if (task1.getEndDate().equals(DEFAULT_END_DATE) && !task2.getEndDate().equals(DEFAULT_END_DATE)) {
			return 1;
		} else if (!task1.getEndDate().equals(DEFAULT_END_DATE) && task2.getEndDate().equals(DEFAULT_END_DATE)) {
			return -1;
		} else if (task1.getEndDate().equals(DEFAULT_END_DATE) && task2.getEndDate().equals(DEFAULT_END_DATE)) {
			return comparePriority(task1, task2);
		} else {
			Date task1DueDate = getDate(task1.getEndDate());
			Date task2DueDate = getDate(task2.getEndDate());
			assert task1DueDate != null && task2DueDate != null;
			int dateComparison = task1DueDate.compareTo(task2DueDate);
			if (dateComparison < 0) {
				return -1;
			} else if (dateComparison > 0) {
				return 1;
			} else {
				return dateComparison;
			}
		}
	}

	private Date getDate(String endDate) {
		try {
			DateFormat dateFormat = new SimpleDateFormat(Task.DATE_FORMAT); 
			return dateFormat.parse(endDate);
		} catch (ParseException e) {
			System.out.println("Parsing " + endDate + " returns a null date");
			return null;
		}
	}

	private int comparePriority(Task task1, Task task2) {
		int task1Priority = getNumberedPriority(task1.getPriority());
		int task2Priority = getNumberedPriority(task2.getPriority());
		if (task1Priority > task2Priority) {
			return -1;
		} else if (task1Priority < task2Priority) {
			return 1;
		} else {
			return 0;
		}
	}

	private int getNumberedPriority(String priority) {
		switch(priority) {
		
			case PRIORITY_HIGH :
		         return 2;
		         //break;
		    
			case PRIORITY_MED :
				 return 1;
				 //break;
			
			case PRIORITY_LOW :
				 //Fallthrough
			
			default :
				 return 0;
				 //break;
		}
	}

	

}
```
###### src\application\ViewCommand.java
``` java
	@Override
	public Feedback execute() {
		int index = findEntry(_content);
		if (index == Command.FIND_NO_ID) {
			assert _content.equals(EMPTY);
			log.warning(LOG_NO_ID);
			return new Feedback(ERROR_NO_ID);
		} else if (index == Command.FIND_INVALID_ID) {
			return new Feedback(ERROR_INVALID_ID);
		} else {
			Task selectedTask = _parse.retrieveTask(_content, _store.entries_);
			ArrayList<Task> data = new ArrayList<Task>();
			data.add(selectedTask);
			String feedbackString = String.format(FEEDBACK_MESSAGE, _content);
			Feedback feedback = new Feedback(feedbackString, data);
			feedback.setSummaryView(false);
			return feedback;
		}
	}

	@Override
	public Feedback undo() {
		return null; 
	}

	public static Instruction generateInstruction() {
		Instruction commandInstruction = new Instruction();
		commandInstruction.setCommandPattern(PATTERN);
	    commandInstruction.addToInstructions(INSTRUCTION_REQUIRED);
	    commandInstruction.addToRequiredFields(REQUIRED_FIELD_ID);
	    return commandInstruction;
	}
	
	
}
```
###### src\gui\CommandBarController.java
``` java
	/**
     * Facilitates outcomes once certain keys are pressed
     *
     * @param requiredField text that will appear on the command bar upon typing
     */
	public void onKeyPress(KeyEvent event) throws IOException {
		commandBar.requestFocus();
		commandBar.setEditable(true);
		if (event.getCode() == KeyCode.ENTER) {
			gui.handleCommand(commandBar.getText());
			commandBar.clear();
		} else if (event.getCode() == KeyCode.SPACE) {
			if(!gui.isHandlingCommand && hasOnlyOneWord()) {
				gui.handleCommandPattern(commandBar.getText().trim());
			}
		} else if (event.getCode() == KeyCode.COMMA) {
			if(gui.isHandlingCommand) {
				hasAComma = true;
				gui.handleCommandPattern();
			} 
		} else if (event.getCode() == KeyCode.UP) {
			gui.isHandlingCommand = false;
			gui.retrievePastCommand();
		} else if (event.getCode() == KeyCode.DOWN) {
			gui.isHandlingCommand = false;
			gui.retrieveNextCommand();
		}
		
		if(gui.isHandlingCommand && commandBar.getText().trim().equals("")) {
			commandBar.clear();
			gui.isHandlingCommand = false;
		}
	}
	
	private boolean hasOnlyOneWord() {
		String[] commands = commandBar.getText().split(" ");
		return commands.length == ONE_WORD;
	}

```
###### src\gui\CommandBarController.java
``` java
	/**
     * Adds required fields onto the command bar as the user types
     *
     * @param requiredField text that will appear on the command bar upon typing
     */
	public void updateCommandBar(String requiredField) {
		if (!requiredField.equals("")) { //add a required field
			commandBar.requestFocus(); // get focus first
			commandBar.setEditable(false); //prevent deletion of the selection
			String commandText = commandBar.getText();
			int startingRange = commandText.length();
			if (hasAComma) {
				commandBar.appendText(", " + requiredField);
				startingRange += 2;
				hasAComma = false;
			} else {
				commandBar.appendText(" " + requiredField);
				startingRange++;
			}
			commandBar.selectRange(startingRange,  startingRange + requiredField.length());
		}
	}
	
```
